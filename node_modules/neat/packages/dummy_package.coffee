@neat ||= {}
@neat.core ||= {}

`/* src/core/types/utils.coffee */`

# This file contains utilities to deal with prototype extensions.

#### def

# Defines a non-enumerable property on the specified constructor's `prototype`.
#
#     def Object, merge: (o) ->
#       # merge implementation
#
#     {foo: 10}.merge bar: 20 # {foo: 10, bar: 20}
def = (ctor, o) ->
  for name, value of o
    Object.defineProperty? ctor.prototype,
                           name,
                           enumerable: false, value: value, writable: true

`/* src/core/types/object.coffee */`

# This file contains Object's extensions that mimics some of the ruby
# Object and Hash methods.
# @toc

## Object

#### Class Extensions

##### Object.new

# Creates a new object from an array such as `[key, value, key, value, ...]`.
#
#     o = Object.new ['foo', 10, 'bar', 20, 'baz', 30]
#     # {foo: 10, bar: 20, baz: 30}
Object.new = (a) -> o = {}; a.step(2, (k,v) -> o[k] = v); return o

#### Instances Extensions

##### Object::concat

# Returns a new object that is the result of the merge of the current
# object with the passed-in argument. If no argument is provided,
# the return a copy of the current object.
#
#     {foo: 'foo', bar: 'bar'}.concat baz: 'baz'
#     # {foo: 'foo', bar: 'bar', baz: 'baz'}
def Object, concat: (m) ->
  o = {}; o[k] = v for k,v of this; return o.merge(m || {})

##### Object::destroy

# Delete the given property and return its previous value.
#
#     o = {foo: 10, bar: 20}
#     o.destroy 'foo' # 10
#     # o = {bar: 20}
def Object, destroy: (key) ->
  if @hasKey key
    res = @[key]
    delete @[key]
    return res
  null

##### Object::each
#
# Iterates over the object enumerable properties and call
# the passed-in function with the key-value pair.
#
#     {foo: 10, bar: 20}.each (k,v) ->
#       # do something with k and v
def Object, each: (f) -> f k,v for k,v of this if f?; this

##### Object::empty

# Returns true if the current object don't contains any enumerable properties.
#
#     {}.empty()        # true
#     {foo: 10}.empty() # false
def Object, empty: -> @keys().empty()

##### Object::first

# Returns the first pair of key and value of the current object as a tuple.
#
#     {foo: 10, bar: 20}.first() # ['foo', 10]
def Object, first: -> if @empty() then null else @flatten().group(2).first()

##### Object::flatten

# Returns an array such as `[key, value, key, value]` with the name
# and the content of the enumerable properties of this object.
#
#     {foo: 10, bar: 20, baz: 30}.flatten()
#     # ['foo', 10, 'bar', 20, 'baz', 30]
def Object, flatten: -> a = []; a = a.concat [k,v] for k,v of this; return a

##### Object::has

# Retuns `true` if the specified values is contained in one of the object
# enumerable properties.
#
#     object =
#       foo: 10
#       bar: 20
#
#     object.has 20 # true
#     object.has 30 # false
def Object, has: (value) -> value in @values()

##### Object::hasKey

# Returns `true` if the specified key is defined on this object.
#
#     object =
#       foo: 10
#       bar: 20
#
#     object.hasKey 'foo' # true
#     object.hasKey 'baz' # false
def Object, hasKey: (key) -> @[key]?

##### Object::keys

# Returns an array of the keys enumerable on this object.
#
# The keys are returned as the `for..in` construct iterates on them.
# Use `sortedKeys` to retreive the keys sorted alphabetically.
#
#     object =
#       foo: 10
#       bar: 20
#
#     object.keys() # ['foo', 'bar']
def Object, keys: -> k for k of this

##### Object::length

# Returns the count of enumerable properties on this object.
#
#     {}.length()                 # 0
#     {foo: 10}.length()          # 1
#     {foo: 10, bar: 20}.length() # 2
def Object, length: -> @keys().length

##### Object::last

# Returns the last pair of key and value of the current object as a tuple.
#
#     {foo: 10, bar: 20}.last() # ['bar', 20]
def Object, last: -> if @empty() then null else @flatten().group(2).last()

##### Object::map

# Iterates over the current object enumerable properties and
# creates a new object with the mapping function's return.
#
#     source = {foo: 10, bar: 50}
#     result = source.map (k,v) -> ["_#{k}_", v * 100]
#     # {_foo_: 1000, _bar_: 5000}
def Object, map: (f) -> Object.new (f(k,v) for k,v of this).flatten()

##### Object::merge

# Merge the enumerable properties of `o` into this object.
#
# A target object property is overriden by the source property
# if both hold the same property.
#
#     target = foo: 10
#     target.merge bar: 20, baz: 30
#     # target = {foo: 10, bar: 20, baz: 30}
def Object, merge: (o) -> @[k] = v for k,v of o; this

##### Object::reject

# Returns an object without the properties that are evaluated as `true`
# in the passed-in filter function.
#
#     source = foo: 10, bar: 20, baz: 30
#     target = source.reject (k,v) -> v > 10
#     # target = {foo: 10}
def Object, reject: (f) ->
  o = {}; o[k] = v for k,v of this when not f? k, v; return o

##### Object::select

# Returns an object with the properties that are evaluated as `true`
# in the passed-in filter function.
#
#     source = foo: 10, bar: 20, baz: 30
#     target = source.select (k,v) -> v > 10
#     # target = {bar: 20, baz: 30}
def Object, select: (f) ->
  o = {}; o[k] = v for k,v of this when f? k, v; return o

##### Object::size

# `Object::length` alias.
def Object, size: -> @length()

##### Object::sort

# Returns a new object whose properties have been sorted to
# be iterated in the defined order.
#
#     source = foo: 10, bar: 20
#     target = source.sort (a,b) ->
#       if a > b then 1 else if b < a then -1 else 0
#     # target = {bar: 20, foo: 10}
#
# If called without arguments the keys are sorted alphabetically.
def Object, sort: (f) ->
  if not f? or typeof f isnt 'function'
    f = (a,b) ->
      if a > b then 1 else if b < a then -1 else 0

  o = {}; o[k] = @[k] for k in @keys().sort f; return o

##### Object::sortedKeys

# Returns the enumerable keys sorted alphabetically.
#
#     object =
#       foo: 10
#       bar: 20
#
#     object.sortedKeys() # ['bar', 'foo']
def Object, sortedKeys: -> @keys().sort()

##### Object::sortedValues

# Returns the values of the enumerable properties of this object.
# The values are ordered such as each key in `sortedKeys` correspond
# to the value at the same index in `sortedValues`.
#
#     object =
#       foo: 10
#       bar: 20
#
#     object.sortedValues() # [20, 10]
def Object, sortedValues: -> @[k] for k in @sortedKeys()

##### Object::type

# Returns the results of calling `Object::toString` on the current object
# and extracting the class name to lower case.
def Object, type: ->
  Object::toString.call(@).toLowerCase().replace /\[object (\w+)\]/, "$1"

##### Object::update

# `Object::merge` alias.
def Object, update: Object::merge

##### Object::values

# Returns the values of the enumerable properties of this object.
# The values are returned as the `for..in` construct iterates on this object.
# Use `sortedValues` to retreive the values based on the alphabetically
# sorted keys.
#
#     object =
#       foo: 10
#       bar: 20
#
#     object.values() # [10, 20]
def Object, values: -> @[k] for k in @keys()

#### Duck Typing

##### Object::quacksLike

# The `Object::quacksLike` method allow to perform a duck test
# on the current object object.
#
# Duck tests are performed by looking for a special `__definition__` field
# on the passed-in `type` object. This field can either contains a function
# or an structure object.
#
# When using a structure object, the keys matched for properties name and
# values can be either a string that will be tested against `typeof value`
# (use `*` to allow any type) or a function that will be called with the
# value as argument.
#
# Below an example of how `quacksLike` can be used with custom
# type definitions:
#
#     Point =
#       __definition__:
#         x: 'number'
#         y: 'number'
#
#     class ConcretPoint
#       constructor: (@x=0, @y=0) ->
#
#     point = new ConcretPoint
#     point.quacksLike Point  # true
#
#     point.x = "foo"
#     point.quacksLike Point  # false
#
#     object = {x: 10, y: 20}
#     object.quacksLike Point # true
#
# An example demonstrating the use of function as definition:
#
#     Command =
#       __definition__: (o) ->
#         typeof o is "function" and o.aliases?
#
#     command = -> # do something
#     command.aliases = ['c', 'command']
#
#     command.quacksLike Command # true
#
# Of course, a class can describe itself in its body:
#
#     class Point
#       @__definition__:
#         x: 'number'
#         y: 'number'
#
#       constructor: (@x, @y) ->
def Object, quacksLike: (type) ->
  if type.__definition__?
    definition = type.__definition__
    return definition this if typeof definition is "function"
    for k,v of definition
      switch typeof v
        when "function" then return false unless v @[k]
        else return false unless (v is "*" or @[k]?.type() is v)
    true
  else
    false



`/* src/core/types/number.coffee */`

# This file contains Number's extensions that mimics some of the ruby
# Number methods.
# @toc

## Number

##### Number::ago

# Returns a `Date` object that correspond to the time of the call
# minus the current number as milliseconds.
#
#     10.hours().ago()
def Number, ago: -> new Date new Date().getTime() - @valueOf()

##### Number::days

# Returns the current number as days converted in milliseconds.
#
#     10.days() # 864000000
def Number, days: -> @hours() * 24

##### Number::even

# Returns `true` if the current number is even.
#
#     4.even() # true
#     5.even() # false
def Number, even: -> @valueOf() % 2 is 0

##### Number::fromNow

# Returns a `Date` object that correspond to the time of the call
# plus the current number as milliseconds.
#
#     10.hours().fromNow()
def Number, fromNow: -> new Date new Date().getTime() + @valueOf()

##### Number::hours

# Returns the current number as hours converted in milliseconds.
#
#     10.hours() # 36000000
def Number, hours: -> @minutes() * 60

##### Number::later

# `Number::fromNow` alias.
Number.later = -> @fromNow()

##### Number::minutes

# Returns the current number as minutes converted in milliseconds.
#
#     10.minutes # 600000
def Number, minutes: -> @seconds() * 60

##### Number::odd

# Returns `true` if the current number is odd.
#
#     4.odd() # false
#     5.odd() # true
def Number, odd: -> @valueOf() % 2 is 1

##### Number::seconds

# Returns the current number as seconds converted in milliseconds.
#
#     6.seconds # 6000
def Number, seconds: -> @valueOf() * 1000

##### Number::times

# Iterates `n` times and call `callback` for each iteration where `n` is
# the current `Number` value.
#
#     5.times (i) -> print "#{i} " # 0 1 2 3 4
#
# You can also multiply objects:
#
#     5.times "*"        # '*****'
#     5.times 10         # 50
#     2.times ['foo', 1] # ['foo', 1, 'foo', 1]
def Number, times: (target) ->
  return (target i for i in [0..@valueOf()-1]) if typeof target is "function"
  o = target

  for i in [1..@valueOf()-1]
    if Array.isArray o
      o = o.concat target
    else
      o += target
  o

##### Number::to

# Iterates from the current value to the passed-in value.
#
#     5.to 10, (i) -> print "#{i} " # 5 6 7 8 9 10
def Number, to: (end, callback) -> callback i for i in [@valueOf()..end]

##### Number::weeks

# Returns the current number as weeks converted in milliseconds.
#
#     1.week # 604800000
def Number, weeks: -> @days() * 7


`/* src/core/types/string.coffee */`

# This file contains String's extensions that mimics some of the ruby
# String methods.
# @toc

## String

#### Instances Extensions

##### String::append

# Returns a new string where `str` have been appended to the original string.
def String, append: (str) -> "#{this}#{str}"

##### String::camelize

# Returns a `camelCase` version of the current string.
#
#     'foo bar'.camelize() # 'fooBar'
#     'foo-bar'.camelize() # 'fooBar'
#     'FOO_BAR'.camelize() # 'fooBar'
def String, camelize: ->
  a = @toLowerCase().split /[_\s-]/
  s = a.shift()
  s = "#{s}#{w.capitalize()}" for w in a
  s

##### String::capitalize

# Returns a string where the case of the first char of the first word was
# changed to upper case.
#
#     'foo bar'.capitalize() # 'Foo bar'
def String, capitalize: ->
  @toLowerCase().replace /^[a-z]/, (m) -> m.toUpperCase()

##### String::capitalizeAll

# Returns a string where the case of the first char of each word was
# changed to upper case.
#
#     'foo bar'.capitalizeAll() # 'Foo Bar'
def String, capitalizeAll: ->
  @toLowerCase().replace /(^|\s)([a-z])/g, (m,a,b) -> "#{a}#{b.toUpperCase()}"

##### String::center

# If `width` is greater than the length of this string, returns a string
# of length `width` with this string's value centered and padded with `pad`;
# otherwise, returns this string.
#
#     'foo'.center 10 # '   foo    '
def String, center: (width=0, pad=' ') ->
  if width > @length
    padLeftLength = Math.floor((width - @length) / 2)
    padRightLength = width - @length - padLeftLength
    @padLeft(padLeftLength, pad).padRight(padRightLength, pad)
  else @valueOf()

##### String::compact

# Removes all space characters in the string.
#
#     'aa bb     cc   dd'.compact() # 'aabbccdd'
def String, compact: -> @replace /\s+/g, ''

##### String::empty

# Returns `true` if the string is empty.
#
#     ''.empty()    # true
#     'foo'.empty() # false
def String, empty: -> @length is 0

##### String::left

# Align the current string to the left in the new string of length `l`.
#
#     'foo'.left 10 # 'foo       '
def String, left: (l) -> @padRight l - @length

##### String::padLeft

# Returns a string padded on the left with `pad` of an amount equal to `left`.
#
#     'foo'.padLeft 4        # '    foo'
#     'foo'.padLeft 4, '123' # '1231foo'
def String, padLeft: (length=0, pad=' ') -> @prepend String.fill length, pad

##### String::padRight

# Returns a string padded on the right with `pad` of an amount equal to `left`.
#
#     'foo'.padRight 4        # 'foo    '
#     'foo'.padRight 4, '123' # 'foo1231'
def String, padRight: (length=0, pad=' ') -> @append String.fill length, pad

##### String::prepend

# Returns a new string where `str` have been prepended to the original string.
def String, prepend: (str) -> "#{str}#{this}"

##### String::parameterize

# Returns a version of the current string that render nicely used in an url.
#
#     "Il était une fois...".parameterize()
#     # 'il-etait-une-fois'
def String, parameterize: ->
  @nopunctuation().nodiacritics().toLowerCase().squeeze().replace /\s/g, '-'

##### String::right

# Align the current string to the right in the new string of length `l`.
#
#     'foo'.right 10 # '       foo'
def String, right: (l) -> @padLeft l - @length

##### String::squeeze

# Returns a new string where all duplicates of the passed-in match are removed.
# The `squeeze` method support char range such as `A-z` or `a-f`.
# By default the `squeeze` method operates on spaces chars.
#
#     'hello   world'.squeeze()      # 'hello world'
#     'hello worllld'.squeeze('l')   # 'helo world'
#     'hello wwoorld'.squeeze('m-z') # 'hello world'
#     'foofoobarbar'.squeeze('foo')  # 'foobarbar'
def String, squeeze: (match='\\s') ->
  rangeRe = /^([A-Za-z_])-([A-Za-z])$/
  re = null

  if rangeRe.test match
    [m,s,e] = rangeRe.exec match
    a = []
    s.to e, (c) -> a.push "#{c}+"

    re = ///#{a.join '|'}///g

  else if match is '\\s'
    re = /\n+| +|\t+/g

  else
    re = ///(#{match})+///g
    return @replace re, (m, w) -> w

  @replace re, (m) -> m.substr 0, 1

##### String::strip

# Removes the spaces at both extremities of the string.
#
#     '   foo'.strip() # 'foo'
#     'foo   '.strip() # 'foo'
def String, strip: -> @replace /^\s+|\s+$/g, ''

##### String::to

# Iterates from the first char of this string to the first char of the `end`
# string using the Unicode of the characters.
#
#     str = ''
#     'A'.to 'z', (c) -> str += c
#     # str = ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz
def String, to: (end, callback) ->
  start = @charCodeAt 0
  end = end.charCodeAt 0
  callback String.fromCharCode i for i in [start..end]

##### String::underscore

# Returns a `snake_case` version of the current string.
#
#     'fooBar'.underscore()  # 'foo_bar'
#     'Foo Bar'.underscore() # 'foo_bar'
#     'FOO-BAR'.underscore() # 'foo_bar'
#     'foo/BAR'.underscore() # 'foo_bar'
def String, underscore: ->
  @replace(/([a-z])([A-Z])/g, "$1_$2")
    .split(/[-/]|\s/g)
    .join("_")
    .toLowerCase()

##### String::nodiacritics

# Removes all the accented characters and ligatures from the string.
#
#     'ÉéÀàÈè'.nodiacritics() # 'EeAaEe'
def String, nodiacritics: ->
  str = this
  str = str.replace v, k for k,v of String.DACRITICS_MAP
  str

##### String::nopunctuation

# Returns the current string without the punctuation.
#
#     'Something, is (wrong): in- this! !phrase?'.nopunctuation()
#     # 'Something is wrong in this phrase'
def String, nopunctuation: ->
  @replace /[,?;.:/!§*%=\[\](){}'"`\\_<>-]/g, ''

#### Class Methods

##### String.fill

# Returns a string of length `length` filled with the chars in `filler`.
#
#     String.fill 3        # '   '
#     String.fill 4, '123' # '1231'
#     String.fill 5, 'ab'  # 'ababa'
String.fill = (length, filler=' ') ->
  s = ''
  fillerChar = 0
  for i in [0..length-1]
    s = "#{s}#{filler[fillerChar++]}"
    fillerChar = 0 if fillerChar >= filler.length
  s

#### Class Properties

##### String.DACRITICS_MAP

# An object that contains all the diacrictics mapped with their corresponding
# replacement char(s).
String.DACRITICS_MAP =
  A: ///[
    \u0041\u24B6\uFF21\u00C0\u00C1
    \u00C2\u1EA6\u1EA4\u1EAA\u1EA8
    \u00C3\u0100\u0102\u1EB0\u1EAE
    \u1EB4\u1EB2\u0226\u01E0\u00C4
    \u01DE\u1EA2\u00C5\u01FA\u01CD
    \u0200\u0202\u1EA0\u1EAC\u1EB6
    \u1E00\u0104\u023A\u2C6F]
  ///g
  AA: /[\uA732]/g
  AE: /[\u00C6\u01FC\u01E2]/g
  AO: /[\uA734]/g
  AU: /[\uA736]/g
  AV: /[\uA738\uA73A]/g
  AY: /[\uA73C]/g
  B: /[\u0042\u24B7\uFF22\u1E02\u1E04\u1E06\u0243\u0182\u0181]/g
  C: ///[
    \u0043\u24B8\uFF23\u0106\u0108
    \u010A\u010C\u00C7\u1E08\u0187
    \u023B\uA73E]
  ///g
  D: ///[
    \u0044\u24B9\uFF24\u1E0A\u010E
    \u1E0C\u1E10\u1E12\u1E0E\u0110
    \u018B\u018A\u0189\uA779]
  ///g
  DZ: /[\u01F1\u01C4]/g
  Dz: /[\u01F2\u01C5]/g
  E: ///[
    \u0045\u24BA\uFF25\u00C8\u00C9
    \u00CA\u1EC0\u1EBE\u1EC4\u1EC2
    \u1EBC\u0112\u1E14\u1E16\u0114
    \u0116\u00CB\u1EBA\u011A\u0204
    \u0206\u1EB8\u1EC6\u0228\u1E1C
    \u0118\u1E18\u1E1A\u0190\u018E]
  ///g
  F: /[\u0046\u24BB\uFF26\u1E1E\u0191\uA77B]/g
  G: ///[
    \u0047\u24BC\uFF27\u01F4\u011C
    \u1E20\u011E\u0120\u01E6\u0122
    \u01E4\u0193\uA7A0\uA77D\uA77E]
  ///g
  H: ///[
    \u0048\u24BD\uFF28\u0124\u1E22
    \u1E26\u021E\u1E24\u1E28\u1E2A
    \u0126\u2C67\u2C75\uA78D]
  ///g
  I: ///[
    \u0049\u24BE\uFF29\u00CC\u00CD
    \u00CE\u0128\u012A\u012C\u0130
    \u00CF\u1E2E\u1EC8\u01CF\u0208
    \u020A\u1ECA\u012E\u1E2C\u0197]
  ///g
  J: /[\u004A\u24BF\uFF2A\u0134\u0248]/g
  K: ///[
    \u004B\u24C0\uFF2B\u1E30\u01E8
    \u1E32\u0136\u1E34\u0198\u2C69
    \uA740\uA742\uA744\uA7A2]
  ///g
  L: ///[
    \u004C\u24C1\uFF2C\u013F\u0139
    \u013D\u1E36\u1E38\u013B\u1E3C
    \u1E3A\u0141\u023D\u2C62\u2C60
    \uA748\uA746\uA780]
  ///g
  LJ: /[\u01C7]/g
  Lj: /[\u01C8]/g
  M: /[\u004D\u24C2\uFF2D\u1E3E\u1E40\u1E42\u2C6E\u019C]/g
  N: ///[
    \u004E\u24C3\uFF2E\u01F8
    \u0143\u00D1\u1E44\u0147
    \u1E46\u0145\u1E4A\u1E48
    \u0220\u019D\uA790\uA7A4]
  ///g
  NJ: /[\u01CA]/g
  Nj: /[\u01CB]/g
  O: ///[
    \u004F\u24C4\uFF2F\u00D2
    \u00D3\u00D4\u1ED2\u1ED0
    \u1ED6\u1ED4\u00D5\u1E4C
    \u022C\u1E4E\u014C\u1E50
    \u1E52\u014E\u022E\u0230
    \u00D6\u022A\u1ECE\u0150
    \u01D1\u020C\u020E\u01A0
    \u1EDC\u1EDA\u1EE0\u1EDE
    \u1EE2\u1ECC\u1ED8\u01EA
    \u01EC\u00D8\u01FE\u0186
    \u019F\uA74A\uA74C]
  ///g
  OI: /[\u01A2]/g
  OO: /[\uA74E]/g
  OU: /[\u0222]/g
  P: /[\u0050\u24C5\uFF30\u1E54\u1E56\u01A4\u2C63\uA750\uA752\uA754]/g
  Q: /[\u0051\u24C6\uFF31\uA756\uA758\u024A]/g
  R: ///[
    \u0052\u24C7\uFF32\u0154
    \u1E58\u0158\u0210\u0212
    \u1E5A\u1E5C\u0156\u1E5E
    \u024C\u2C64\uA75A\uA7A6
    \uA782]
  ///g
  S: ///[
    \u0053\u24C8\uFF33\u1E9E
    \u015A\u1E64\u015C\u1E60
    \u0160\u1E66\u1E62\u1E68
    \u0218\u015E\u2C7E\uA7A8
    \uA784]
  ///g
  T: ///[
    \u0054\u24C9\uFF34\u1E6A
    \u0164\u1E6C\u021A\u0162
    \u1E70\u1E6E\u0166\u01AC
    \u01AE\u023E\uA786]
  ///g
  TZ: /[\uA728]/g
  U: ///[
    \u0055\u24CA\uFF35\u00D9
    \u00DA\u00DB\u0168\u1E78
    \u016A\u1E7A\u016C\u00DC
    \u01DB\u01D7\u01D5\u01D9
    \u1EE6\u016E\u0170\u01D3
    \u0214\u0216\u01AF\u1EEA
    \u1EE8\u1EEE\u1EEC\u1EF0
    \u1EE4\u1E72\u0172\u1E76
    \u1E74\u0244]
  ///g
  V: /[\u0056\u24CB\uFF36\u1E7C\u1E7E\u01B2\uA75E\u0245]/g
  VY: /[\uA760]/g
  W: /[\u0057\u24CC\uFF37\u1E80\u1E82\u0174\u1E86\u1E84\u1E88\u2C72]/g
  X: /[\u0058\u24CD\uFF38\u1E8A\u1E8C]/g
  Y: ///[\u0059\u24CE\uFF39\u1EF2
    \u00DD\u0176\u1EF8\u0232
    \u1E8E\u0178\u1EF6\u1EF4
    \u01B3\u024E\u1EFE]
  ///g
  Z: ///[
    \u005A\u24CF\uFF3A\u0179
    \u1E90\u017B\u017D\u1E92
    \u1E94\u01B5\u0224\u2C7F
    \u2C6B\uA762]
  ///g
  a: ///[
    \u0061\u24D0\uFF41\u1E9A
    \u00E0\u00E1\u00E2\u1EA7
    \u1EA5\u1EAB\u1EA9\u00E3
    \u0101\u0103\u1EB1\u1EAF
    \u1EB5\u1EB3\u0227\u01E1
    \u00E4\u01DF\u1EA3\u00E5
    \u01FB\u01CE\u0201\u0203
    \u1EA1\u1EAD\u1EB7\u1E01
    \u0105\u2C65\u0250]
  ///g
  aa: /[\uA733]/g
  ae: /[\u00E6\u01FD\u01E3]/g
  ao: /[\uA735]/g
  au: /[\uA737]/g
  av: /[\uA739\uA73B]/g
  ay: /[\uA73D]/g
  b: /[\u0062\u24D1\uFF42\u1E03\u1E05\u1E07\u0180\u0183\u0253]/g
  c: ///[
    \u0063\u24D2\uFF43\u0107
    \u0109\u010B\u010D\u00E7
    \u1E09\u0188\u023C\uA73F
    \u2184]
  ///g
  d: ///[
    \u0064\u24D3\uFF44\u1E0B
    \u010F\u1E0D\u1E11\u1E13
    \u1E0F\u0111\u018C\u0256
    \u0257\uA77A]
  ///g
  dz: /[\u01F3\u01C6]/g
  e: ///[
    \u0065\u24D4\uFF45\u00E8
    \u00E9\u00EA\u1EC1\u1EBF
    \u1EC5\u1EC3\u1EBD\u0113
    \u1E15\u1E17\u0115\u0117
    \u00EB\u1EBB\u011B\u0205
    \u0207\u1EB9\u1EC7\u0229
    \u1E1D\u0119\u1E19\u1E1B
    \u0247\u025B\u01DD]
  ///g
  f: /[\u0066\u24D5\uFF46\u1E1F\u0192\uA77C]/g
  g: ///[
    \u0067\u24D6\uFF47\u01F5
    \u011D\u1E21\u011F\u0121
    \u01E7\u0123\u01E5\u0260
    \uA7A1\u1D79\uA77F]
  ///g
  h: ///[
    \u0068\u24D7\uFF48\u0125
    \u1E23\u1E27\u021F\u1E25
    \u1E29\u1E2B\u1E96\u0127
    \u2C68\u2C76\u0265]
  ///g
  hv: /[\u0195]/g
  i: ///[
    \u0069\u24D8\uFF49\u00EC
    \u00ED\u00EE\u0129\u012B
    \u012D\u00EF\u1E2F\u1EC9
    \u01D0\u0209\u020B\u1ECB
    \u012F\u1E2D\u0268\u0131]
  ///g
  j: /[\u006A\u24D9\uFF4A\u0135\u01F0\u0249]/g
  k: ///[
    \u006B\u24DA\uFF4B\u1E31
    \u01E9\u1E33\u0137\u1E35
    \u0199\u2C6A\uA741\uA743
    \uA745\uA7A3]
  ///g
  l: ///[
    \u006C\u24DB\uFF4C\u0140
    \u013A\u013E\u1E37\u1E39
    \u013C\u1E3D\u1E3B\u017F
    \u0142\u019A\u026B\u2C61
    \uA749\uA781\uA747]
  ///g
  lj: /[\u01C9]/g
  m: /[\u006D\u24DC\uFF4D\u1E3F\u1E41\u1E43\u0271\u026F]/g
  n: ///[
    \u006E\u24DD\uFF4E\u01F9
    \u0144\u00F1\u1E45\u0148
    \u1E47\u0146\u1E4B\u1E49
    \u019E\u0272\u0149\uA791
    \uA7A5]
  ///g
  nj: /[\u01CC]/g
  o: ///[
    \u006F\u24DE\uFF4F\u00F2
    \u00F3\u00F4\u1ED3\u1ED1
    \u1ED7\u1ED5\u00F5\u1E4D
    \u022D\u1E4F\u014D\u1E51
    \u1E53\u014F\u022F\u0231
    \u00F6\u022B\u1ECF\u0151
    \u01D2\u020D\u020F\u01A1
    \u1EDD\u1EDB\u1EE1\u1EDF
    \u1EE3\u1ECD\u1ED9\u01EB
    \u01ED\u00F8\u01FF\u0254
    \uA74B\uA74D\u0275]
  ///g
  oi: /[\u01A3]/g
  ou: /[\u0223]/g
  oo: /[\uA74F]/g
  p: /[\u0070\u24DF\uFF50\u1E55\u1E57\u01A5\u1D7D\uA751\uA753\uA755]/g
  q: /[\u0071\u24E0\uFF51\u024B\uA757\uA759]/g
  r: ///[
    \u0072\u24E1\uFF52\u0155
    \u1E59\u0159\u0211\u0213
    \u1E5B\u1E5D\u0157\u1E5F
    \u024D\u027D\uA75B\uA7A7
    \uA783]
  ///g
  s: ///[
    \u0073\u24E2\uFF53\u00DF
    \u015B\u1E65\u015D\u1E61
    \u0161\u1E67\u1E63\u1E69
    \u0219\u015F\u023F\uA7A9
    \uA785\u1E9B]
  ///g
  t: ///[
    \u0074\u24E3\uFF54\u1E6B
    \u1E97\u0165\u1E6D\u021B
    \u0163\u1E71\u1E6F\u0167
    \u01AD\u0288\u2C66\uA787]
  ///g
  tz: /[\uA729]/g
  u: ///[
    \u0075\u24E4\uFF55\u00F9
    \u00FA\u00FB\u0169\u1E79
    \u016B\u1E7B\u016D\u00FC
    \u01DC\u01D8\u01D6\u01DA
    \u1EE7\u016F\u0171\u01D4
    \u0215\u0217\u01B0\u1EEB
    \u1EE9\u1EEF\u1EED\u1EF1
    \u1EE5\u1E73\u0173\u1E77
    \u1E75\u0289]
  ///g
  v: /[\u0076\u24E5\uFF56\u1E7D\u1E7F\u028B\uA75F\u028C]/g
  vy: /[\uA761]/g
  w: /[\u0077\u24E6\uFF57\u1E81\u1E83\u0175\u1E87\u1E85\u1E98\u1E89\u2C73]/g
  x: /[\u0078\u24E7\uFF58\u1E8B\u1E8D]/g
  y: ///[
    \u0079\u24E8\uFF59\u1EF3
    \u00FD\u0177\u1EF9\u0233
    \u1E8F\u00FF\u1EF7\u1E99
    \u1EF5\u01B4\u024F\u1EFF]
  ///g
  z: ///[
    \u007A\u24E9\uFF5A\u017A
    \u1E91\u017C\u017E\u1E93
    \u1E95\u01B6\u0225\u0240
    \u2C6C\uA763]
  ///g

`/* src/core/types/array.coffee */`

# This file contains Array's extensions that mimics some of the ruby
# Array methods.
# @toc

## Array

#### Class Extensions

##### Array.isArray

# Returns `true` if the passed-in object is an `Array`. This function
# use the `Object.prototype.toString` hack to test the passed-in object.
Array.isArray = (a) -> Object::toString.call(a) is '[object Array]'

#### Instances Extensions

##### Array::compact

# Returns a new array without all the undefined elements of the previous array.
#
#     ['foo', null, 10].compact() # ['foo', 10]
def Array, compact: -> @select (el) -> el?

##### Array::empty

# Returns `true` if the array is empty.
#
#     [].empty()      # true
#     ['foo'].empty() # false
def Array, empty: -> @length is 0

##### Array::first

# Returns the first element in this array.
#
#     ['foo', 'bar'].first() # 'foo'
def Array, first: -> if @length > 0 then @[0] else undefined

##### Array::flatten

# Returns a new array that is a recursice one-dimensional flattening
# of this array.
# The `level` argument allow to specify the depth at which stopping
# the flattening.
#
#     [0, [1, 2, [3, 4, [5]]]].flatten()  # [0, 1, 2, 3, 4, 5]
#     [0, [1, 2, [3, 4, [5]]]].flatten(1) # [0, 1, 2, [3, 4, [5]]]
#     [0, [1, 2, [3, 4, [5]]]].flatten(2) # [0, 1, 2, 3, 4, [5]]
def Array, flatten: (level = Infinity) ->
  level = Infinity if level < 0
  a = []
  for el in this
    if Array.isArray(el) and level isnt 0
      a = a.concat el.flatten(level-1)
    else
      a.push el
  a

##### Array::group

# Returns an array whose values are grouped together in arrays
# of length `size`.
#
#     ['foo', 'bar', 'baz'].group 2
#     # [['foo', 'bar'], ['baz']]
def Array, group: (size) ->
  a = []; @step(size, -> a.push (v for v in arguments)); return a

##### Array::last

# Returns the last element in this array.
#
#     ['foo', 'bar'].last() # 'bar'
def Array, last: -> if @length > 0 then @[@length-1] else undefined

##### Array::max

# Returns the maximum value contained in this array.
#
#     [0, 10, 20, 30].max() # 30
def Array, max: -> Math.max.apply null, this

##### Array::min

# Returns the minimum value contained in this array.
#
#     [0, 10, 20, 30].min() # 0
def Array, min: -> Math.min.apply null, this

##### Array::reject

# Returns a new array that contains the elements of this array that wasn't
# rejected by the provided function.
# If no function is provided a copy of this array is returned.
#
#     ['foo', 'bar', 'baz'].reject (v) -> v.substr(0, 1) is "b"
#     # ['foo']
def Array, reject: (f) -> o for o in this when not f? o

##### Array::rotate

# Returns a new array which contains the elements of this array rotated
# according to the passed-in amount.
# The original array is leaved unchanged.
#
#     ['a', 'b', 'c', 'd'].rotate()   # ['b', 'c', 'd', 'a']
#     ['a', 'b', 'c', 'd'].rotate(2)  # ['c', 'd', 'a', 'b']
#     ['a', 'b', 'c', 'd'].rotate(-1) # ['d', 'a', 'b', 'c']
def Array, rotate: (amount=1) ->
  amount = 1 if amount is 0
  direction = amount > 0
  out = @concat()
  range = [0..Math.abs(amount)-1]
  if direction
    out.push out.shift() for i in range
  else
    out.unshift out.pop() for i in range
  out

##### Array::select

# Returns a new array which contains the elements of this array that
# was selected by the provided function.
# If no function is provided an empty array is returned.
#
#     ['foo', 'bar', 'baz'].select (v) -> v.substr(0, 1) is "b"
#     # ['bar', 'baz']
def Array, select: (f) -> o for o in this when f? o

##### Array::step

# Iterates over the array according to the given step.
#
#     ['foo', 'bar', 'baz'].step 2, (a, b) -> console.log a, b
#     # 'foo' 'bar'
#     # 'baz' undefined
def Array, step: (n,f) ->
  f?.apply this, @[i*n..i*n + n-1] for i in [0..Math.ceil(@length / n)-1]

##### Array::uniq

# Returns a new array where all values are unique.
#
#     ['foo', 'foo', 'bar'].uniq() # ['foo', 'bar']
def Array, uniq: ->
  out = []
  out.push v for v in this when v not in out
  out


`/* src/core/mixin.coffee */`

# The `Mixin` function takes an object and decorates it with
# the mixins functionalities.
#
#     Serializable = Mixin
#       toSource: -> # ...
#       fromSource: (string) -> # ...
#
#     class Dummy
#       @include Serializable
Mixin = (mixin) ->
  # Keep a reference to the original mixin `included` hook.
  # The mixin `included` hook is called whenever the mixin
  # is used to decorate a class.
  #
  #     Serializable = Mixin
  #       included: (ctor) ->
  #         # Do something with ctor
  included = mixin.included

  # The mixin `included` hook is redefine to handle the insertion
  # of the mixin in the `__mixins__` array of the decorated constructor.
  mixin.included = (base) ->
    # The original mixin `included` hook is triggered.
    included? base

    # Register this mixin in the `__mixins__` array of the decorated
    # class.
    base.__mixins__ ?= []
    base.__mixins__.push mixin unless mixin in base.__mixins__

  # Features added to the mixin by the `Mixin` function are excluded
  # of the decoration process of the `Module.include` method.
  mixin.excluded = ["isMixinOf", "__definition__"]

  ##### Mixin.isMixinOf

  # Returns `true` if the passed-in object's constructor have been
  # decorated with the current mixin.
  #
  #     Serializable = Mixin
  #       toSource: -> # ...
  #       fromSource: (string) -> # ...
  #
  #     class Dummy
  #       @include Serializable
  #
  #     dummy = new Dummy
  #     Serializable.isMixinOf dummy # true
  mixin.isMixinOf = (object) ->
    mixin in object.constructor.__mixins__ if object.constructor.__mixins__?

  mixin

`/* src/core/module.coffee */`

#@toc

# Modules allow polymorphism through mixins.
#
# A Mixin is an object whose properties will
# be used to decorate a class prototype.
#
#     Serializable =
#       toSource: -> # ...
#       fromSource: (string) -> # ...
#
#     Cloneable =
#       clone: -> # ...
#

## Module

# The `Module` class is a base class that you can extend
# to create classes with polymorphism ability.
`/* src/core/module.coffee<Module> line:20 */`
class Module
  #### Class Members

  ##### Module.include

  # Call the static `@include` method in your class body
  # to specify the mixins that the class will implement.
  #
  #     class MyModule extends Module
  #       @include Serializable, Cloneable, Suspendable
  #
  #       # rest of the class definition...
  #
  `/* src/core/module.coffee<Module.include> line:33 */`
  @include: (mixins...) ->

    # Calling `super` inside a mixin method that overides
    # a inherited method will fail. To resolve it, a `@super`
    # method is provided on instances. And to avoid issues
    # when accessing the constructor of the overridden method
    # in a subclass, the constructor of a mixin method (the class
    # the method was originally mixed in) is registered in a hash
    # stored on the prototype.
    #
    # A copy the hash is made each time the `mixins` method is called.
    # It prevents the hash of a parent class to be affected by changes
    # made in child class.
    @__superOf__ = @__superOf__.concat()

    __excluded__ = ["constructorHook", "included", "excluded"]
    for mixin in mixins
      excluded = if mixin.excluded?
        __excluded__.concat mixin.excluded
      else
        __excluded__.concat()

      # Each member of each mixin is added to the current class
      # prototype, unless the member is part of the excluded array.
      for key, value of mixin when key not in excluded
        @::[key] = value

        # The current class is registered as constructor for
        # for the mixed method.
        @__superOf__[key] = @__super__ if typeof value is 'function'

      # Mixins can provide a function called `constructorHook`.
      # That function will be stored in a specific prototype
      # property and then triggered at the end of the `Module`
      # constructor.
      if mixin.constructorHook?
        hook = mixin.constructorHook
        @__hooks__ = @__hooks__.concat hook

    # The mixin is notified of its inclusion at the end of the process.
    mixin.included? this
    this

  ##### Module.\_\_hooks\_\_

  # Stores the mixins constructor hooks.
  @__hooks__: []

  ##### Module.\_\_superOf\_\_

  # Stores the respective super objects of mixed methods.
  @__superOf__: {}

  #### Instance Members

  ##### Module::preventConstructorHooksInModule

  # When `preventConstructorHooksInModule` is `true`, the `Module`
  # constructor will not triggers the constructor hooks, allowing
  # a subclass to handle the hooks in its own constructor.
  #
  # Subclasses that prevent the `Module` constructor to trigger
  # the hooks should provide the same kind of guards in their
  # constructor to allow their subclasses to do so.
  preventConstructorHooksInModule: false

  ##### Module::constructor

  # The `Module` constructor behavior is to automatically
  # triggers the constructor hooks.
  `/* src/core/module.coffee<Module::constructor> line:103 */`
  constructor: ->
    @triggerConstructorHooks() unless @preventConstructorHooksInModule

  ##### Module::triggerConstructorHooks

  # Loop through all the constructor hooks and call
  # them with the current object as context.
  `/* src/core/module.coffee<Module::triggerConstructorHooks> line:110 */`
  triggerConstructorHooks: ->
    hook.call this for hook in @constructor.__hooks__

  ##### Module::super

  # Use `@super "methodName"` in a mixin's function to call the
  # super function of the specified method.
  `/* src/core/module.coffee<Module::super> line:117 */`
  super: (method, args...) ->
    @constructor.__superOf__[method]?[method]?.apply this, args

`/* src/core/signal.coffee */`

# Use a `Signal` object wherever you need to dispatch an event.
# A `Signal` is a dispatcher that have only one channel.
# @toc

## Signal

# Signals are generally defined as property of an object. And
# their name generally end with a past tense verb, such as in:
#
#     myObject.somethingChanged = new Signal
`/* src/core/signal.coffee<Signal> line:11 */`
class Signal

  ##### Signal::constructor

  # Optionally, a signal can have a specific signature.
  # A signature is a collection of argument names such:
  #
  #     positionChanged = new Signal 'target', 'position'
  #
  # If a signature is passed to a signal, every listener
  # added to the signal must then match the signature.
  #
  #     positionChanged.add (target, position) ->
  #       # will be registered
  #     positionChanged.add (target, position, callback) ->
  #       # will be registered too
  #     positionChanged.add () -> # will throw an error
  #
  # In the case of an asynchronous listener, the callback argument
  # is not considered as being part of the signature.
  `/* src/core/signal.coffee<Signal::constructor> line:31 */`
  constructor: (@signature...) ->
    @listeners = []
    # The `asyncListeners` property stores the number of asynchronous
    # listeners to use a synchronous dispatch when equal to 0.
    @asyncListeners = 0

  #### Listeners management
  #
  # Listeners are stored internally as an array with the form:
  #
  #     [listener, context, calledOnce, priority]

  ##### Signal::add

  # You can register a listener with or without a context.
  # The context is the object that can be accessed through `this`
  # inside the listener function body.
  #
  # An optional `priority` argument allow you to force
  # an order of dispatch for a listener.
  #
  # Signals listeners can be asynchronous, in that case the last
  # argument of the listener must be named `callback`. An async
  # listener blocks the dispatch loop until the callback function
  # passed to the listener is triggered.
  #
  #     # sync listener
  #     signal.add (a, b, c) ->
  #
  #     # async listener
  #     signal.add (a, b, c, callback) -> callback()
  `/* src/core/signal.coffee<Signal::add> line:62 */`
  add: (listener, context, priority = 0) ->
    @validate listener

    # A listener can be registered several times, but only
    # if the context object is different each time.
    #
    # In other words, the following is possible:
    #
    #     listener = ->
    #     context = {}
    #     myObject.signal.add listener
    #     myObject.signal.add listener, context
    #
    # When the following is not:
    #
    #     listener = ->
    #     myObject.signal.add listener
    #     myObject.signal.add listener
    if not @registered listener, context
      @listeners.push [listener, context, false, priority]
      @asyncListeners++ if @isAsync listener

      # Listeners are sorted according to their order each time
      # a new listener is added.
      @sortListeners()

  ##### Signal::addOnce

  # Listeners can be registered for only one call.
  #
  # All the others rules are the same. So you can't add
  # the same listener/context couple twice through the two methods.
  `/* src/core/signal.coffee<Signal::addOnce> line:94 */`
  addOnce: (listener, context, priority = 0) ->
    @validate listener
    if not @registered listener, context
      @listeners.push [listener, context, true, priority]
      @asyncListeners++ if @isAsync listener
      @sortListeners()

  ##### Signal::remove

  # Listeners can be removed, but only with the context with which
  # they was added to the signal.
  #
  # In this regards, avoid to register listeners without a context.
  # If later in the application a context is forgotten or invalid
  # when removing a listener from this signal, the listener
  # without context will end up being removed.
  `/* src/core/signal.coffee<Signal::remove> line:110 */`
  remove: (listener, context) ->
    if @registered listener, context
      @asyncListeners-- if @isAsync listener
      @listeners.splice @indexOf(listener, context), 1

  ##### Signal::removeAll

  # All listeners can be removed at once if needed.
  #
  #     signal.removeAll()
  `/* src/core/signal.coffee<Signal::removeAll> line:120 */`
  removeAll: ->
    @listeners = []
    @asyncListeners = 0

  ##### Signal::indexOf

  # `indexOf` returns the position of the listener/context couple
  # in the listeners array.
  `/* src/core/signal.coffee<Signal::indexOf> line:128 */`
  indexOf: (listener, context) ->
    return i for [l,c],i in @listeners when listener is l and context is c
    -1

  ##### Signal::registered

  # Use the `registered` method to test whether a listener/context couple
  # have been registered in this signal.
  `/* src/core/signal.coffee<Signal::registered> line:136 */`
  registered: (listener, context) ->
    @indexOf(listener, context) isnt -1

  ##### Signal::hasListeners

  # Returns true if the signal has listeners.
  `/* src/core/signal.coffee<Signal::hasListeners> line:142 */`
  hasListeners: -> @listeners.length isnt 0

  ##### Signal::sortListeners

  # The listeners are sorted according to their `priority`.
  # The higher the priority the lower the listener will be
  # in the call order.
  `/* src/core/signal.coffee<Signal::sortListeners> line:149 */`
  sortListeners: ->
    return if @listeners.length <= 1
    @listeners.sort (a, b) ->
      [pA, pB ] = [ a[3], b[3]]

      if pA < pB then 1 else if pB < pA then -1 else 0

  ##### Signal::validate

  # Throws an error if the passed-in listener's signature
  # doesn't match the signal's one.
  #
  #     signal = new Signal 'a', 'b', 'c'
  #     signal.validate () -> # false
  #     signal.validate (a,b,c) -> # true
  #     signal.validate (a,b,c,callback) -> # true
  `/* src/core/signal.coffee<Signal::validate> line:165 */`
  validate: (listener) ->
    if @signature.length > 0
      re = /[^(]+\(([^)]+)\).*$/m
      listenerSignature = Function::toString.call(listener).split('\n').shift()
      signature = listenerSignature.replace(re, '$1')
      args = signature.split /\s*,\s*/g

      args.shift() if args.first() is ''
      args.pop() if args.last() is 'callback'

      s1 = @signature.join()
      s2 = args.join()

      m = "The listener #{listener} doesn't match the signal's signature #{s1}"
      throw new Error m if s2 isnt s1

  ##### Signal::isAsync

  # Returns `true` if the passed-in `listener` is asynchronous.
  #
  #     signal.isAsync -> # false
  #     signal.isAsync (callback) -> # true
  `/* src/core/signal.coffee<Signal::isAsync> line:187 */`
  isAsync: (listener) ->
    Function::toString.call(listener).indexOf('callback)') != -1

  #### Signal Dispatch

  ##### Signal::dispatch

  # Signals are dispatched to all the listeners. All the arguments
  # passed to the dispatch become the signal's message.
  #
  #     signal.dispatch this, true
  #
  # Listeners registered for only one call will be removed after
  # the call.
  #
  # Optionally you can pass a callback argument to the dispatch function.
  # In that case, the callback must be the last argument passed to the
  # `dispatch` function.  This function will be called at the end
  # of the dispatch, allowing to execute code after all listeners,
  # even asynchronous, have been triggered.
  #
  #     signal.dispatch this, true, ->
  #       # all listeners have finish their execution
  #
  # **Note:** As the dispatch function will automatically consider
  # the last argument as the callback if its type is `function`, you should
  # avoid using function as the sole argument or as the last argument
  # for a listener. If that case occurs, consider either re-arranging the
  # arguments order or using a value object to carry the function.
  `/* src/core/signal.coffee<Signal::dispatch> line:216 */`
  dispatch: (args..., callback)->
    unless typeof callback is 'function'
      args.push callback
      callback = null

    listeners = @listeners.concat()
    # If at leat one listener is async, the whole dispatch process is async
    # otherwise the fast route is used.
    if @asyncListeners > 0
      next = (callback) =>
        if listeners.length
          [listener, context, once, priority] = listeners.shift()

          if @isAsync listener
            listener.apply context, args.concat =>
              @remove listener, context if once
              next callback
          else
            listener.apply context, args
            @remove listener, context if once
            next callback
        else
          callback?()

      next callback
    else
      # The fast route is just a loop over the listeners.
      # At that point, if your listener do async stuff, it will
      # not prevent the dispatching until it's done.
      for [listener, context, once, priority] in listeners
        listener.apply context, arguments
        @remove listener, context if once

      callback?()

`/* test/fixtures/tasks/package/invalid.coffee */`


f 0


@neat.core.def = def
@neat.core.Mixin = Mixin
@neat.core.Module = Module
@neat.core.Signal = Signal